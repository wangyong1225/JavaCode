顺序存储二叉树的特点：
1、顺序二叉树通常只考虑完全二叉树
2、第n个元素的左子节点为2*n+1
3、第n个元素的右子节点为2*n+2
4、第n个元素的父节点为（n-1）/2
5、n表示二叉树中的第n个元素


线索化二叉树
n个结点的二叉树有n+1个空指针域，利用二叉表中的空指针域，存放指向该节点在某种遍历次序下的前驱
和后驱节点的指针
这种加上了线索的二叉链表称为线索链表，相应的二叉树为线索二叉树，根据线索性质的不同可分为不同
线索二叉树

当线索化二叉树后，node节点的属性left和right，有如下情况：
1）left指向的左子树，也可能是指向的是前驱结点
2）right指向的是右子树，也可能是指向后继节点

赫夫曼树几个重要概念和举例说明
1、路径和路径长度：在一颗树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。
通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1
2、结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为结点的权。
结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积
3、树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length)
权值越大的结点离根结点越近的二叉树才是最优二叉树。
4、WPL最小的就是赫夫曼树

{13, 7, 8, 3, 29, 6, 1}
构成赫夫曼树的步骤
1、从小到大进行排序，将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗简单的二叉树
2、取出根结点权值最小的两颗树
3、组成一颗新的二叉树，该新的二叉树的根结点的权值是前面两颗二叉树根结点权值的和
4、再将这颗新的二叉树，以根结点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理。就
得到一颗赫夫曼树

赫夫曼编码
赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%~90%之间
赫夫曼码是可变字长编码（VLC）的一种，Huffman于1952年提出一种编码方法。称为最佳编码

变长编码  用新的编码来代替ASC码，但不是前缀编码，会出现歧义

1、统计传输的字符串各个字符的个数
2、按照字符次数构建赫夫曼树
3、根据赫夫曼树，给各个字符规定编码，各个层数按照0,1,0,1...编码，叶子结点的字符为路径编码结合组成


二叉排序树（binary sort tree, BST）
任何一个结点的左子结点比当前结点小，右子结点比当前结点大

二叉排序树的删除

1、删除叶子结点
2、删除只有一颗子树的结点
3、删除有两颗子树的结点

思路：
第一种情况
1、找到要删除的结点
2、找到targetNode的父节点parent（是否存在父节点）
3、判断targetNode是左子结点还是右子结点
4、进行删除

第二种情况
1,2相同
3、

平衡二叉树AVL树
它是一颗空树或它的左右两个子树的高度差的绝对值不超过1.平衡二叉树常用的实现方法有红黑树、AVL、替罪羊树，Treap、伸展树等
左旋转
1、创建一个新的结点，值等于当前结点的左子树
2、把新结点的左子树设置为当前结点的左子树
newNode.left = cur.left
3、把新结点的右子树设置为当前结点的右子树的左子树
newNode.right = cur.right.left
4、把当前结点的值换为右子节点的值
cur.value = right.value
5、把当前结点的右子树设置成右子树的右子树
cur.right = cur.right.right
6、把当前结点的左子树设置为新结点
cur.left = newNode


1、当符合右旋转的条件时
2、如果他的左子树的右子树高度大于它的左子树的高度时
3、先对当前这个结点的左结点进行左旋转
4、再对当前结点进行右旋转的操作

















